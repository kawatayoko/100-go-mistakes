- はじめにやったこと
    - mkdir 100-go-mistakes 
    - cd 100-go-mistakes
    - git init
    - h repo create --private --source=.
    - go mod init github.com/kawatayoko/100-go-mistakes

- init関数(p14)
    - 引数を取らない
    - 結果も返さない
    - パッケージが初期化される際にinit関数が実行される

- getterとsetter
    - 慣用的に作成すべきではない。
    - 関数の命名
        - getter -> Balance()
        - setter -> gerBalance()

- インターフェース汚染
    - 不必要な抽象化でコードを埋め尽くし、理解しにくくすること
    - 抽象化は作成するものではなく、発見するもの
        - インターフェースは必要なときに作成するのであって、必要だと予想されるときに作成するものではない
        - 開発者は後で必要になると考えて完璧な抽象化レベルを推測して、コードに過剰な機能を持たせることがよくある
            - ほとんどの場合不必要な抽象化によってコードが汚染され、読むのが複雑になるので、そのようなことは避けるべき
        - Rob Pikeの格言
            - インターフェースで設計するのではなく、インターフェースを発見するのです
    - インターフェースとは
        - オブジェクトの振る舞いを指定する方法を提供する
        - Rob Pikeの格言
            - インターフェースが大きければ大きいほど、抽象化は弱くなる
        - リスコフの置換原則
        - インターフェースは使う側が決めるもの、というGoの設計思想

- メソッドと関数
    - golangにおいて、メソッドと関数は異なる。
    - メソッド = レシーバー関数
    - 関数 = レシーバー関数以外の関数
    - ジェネリクスは関数の引数には使えるが、メソッドの引数には使用できない

- ジェネリクスについて
    - ジェネリクスは特定の条件下では役立つが使用には慎重になるべき
    - ジェネリクスは抽象化の一種であり、不必要な抽象化は複雑さをもたらす
    - 不必要な抽象化でコードを汚染しないようにすること

- 型埋め込みについて
    - 埋め込んだ型がインターフェースを実装していれば、それを持つ型も実装しているとみなせる。
    - シンタックスシュガーという役割だけで使うべきではない。
    - 外部から隠蔽したいデータや振る舞い（メソッド）をプロモートすべきではない

- 関数オプションパターン
    - Config構造体
        - ゼロ値の0と指定された0とを区別できない
        - 解決方法として、整数ポインタの利用があるが、整数ポインタはクライアントにとって使いにくい
        - すべてデフォルト値の場合、からの構造体を渡す必要がある
            - ちょっとカッコ悪い
    - builderパターン

- 3章 データ型
    - Goでは、16進数(0x)、10進数、8進数(0o)、2進数(0b)を扱う。
    - スライス
        - 容量が足りなくなった場合、Goではスライスは1024要素になるまで2倍で増え、それ以降は25%づつ増えていく。
        - 参照されなくなったスライスはヒープ上にあれば、GCにより解放される
        - nilスライスか空スライスかを区別するようにすべきではない
        - nilスライスでも空スライスでも同じ処理をするために、len(slice) != 0 というふうに長さで判定すべき

- 4章 制御構造
    - range構造体
        - for range xxx の場合、式は一度だけ評価される
            - 与えられた式が一時変数にコピーされ、その変数に対してrangeが反復処理をする
    - 従来のforループ
        - for i = 0; i < len(s); i++ {}　の場合、反復ごとに評価される
            - 以下のようなPGはforループが終了しない
            ```
                s := []int{1, 2, 3}
                for i = 0; i < len(s); i++ {
                    s = append(s, 10)
                }
            ```
    - mapを反復処理する際に順序を仮定すべきではない
        - mapは二分木に基づいていない。
            - キーでソートして保持されているわけではない。
        - mapはデータ追加順序を保持しているわけでもない。
        - Goではmapの反復順序は定められていない。
            - ランダムではなく、定められていない。
            - 言語設計者が意図的にそのようにしている。
            - encodeing/jsonパッケージがマップをJSONにマーシャルするとき、データをキーでアルファベット順に並び替えるが、これはGoマップの特性ではない

- 5章 文字列
    - Goの文字列は以下のものを保持する不変な（immutable）データ構造です。
        - 不変なバイト列へのポインタ
        - そのバイト列内のバイトの総数
    - 文字セットとエンコーディング
        - 文字セット
            文字の集合、Unicodeの文字セット
        - エンコーディング
            文字のリストを2進数に翻訳したもの
    - Unicode
        - コードポイント
            - runeは、Unicodeのコードポイント
            - Unicodeのコードポイントは21ビット
            - Goではコードポイントを保持するためのruneはint32のエイリアス
